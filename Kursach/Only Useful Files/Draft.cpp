#include <string>
#include <map>
#include <iostream>
#include <vector>
#include <stack>
#define _USE_MATH_DEFINES
#include <math.h>
#include "ExprElems.h"

using namespace std;

//Преобразование из инфиксной в потсфиксную
/*Скорее всего тип выходного постфиксного выражения*/ /*Название*/ (/*Инфиксное выражение*/) {
	//Скорее всего создание выходного выражения и стэка
	for (/*Цикл по элементам инфиксного выражения*/) { //Цикл по выражению
		 //Считываем очередной элемент
		if (/*Элемент - число или постфикс*/) {
			//Добавляем в постфиксную строку
		}
		else {
			if (/*Элемент - префиксная функция*/) {
				//Помещаем в стэк
			}
			else {
				if (/*Если элемент - открывающая скобка*/) {
					//Помещаем в стэк
				}
				else {
					if (/*Если элемент - закрывающая скобка*/) {
						while (/*Верхний элемент стэка - не открывающая скобка И стэк не кончился*/) {
							if (/*Если следующий элемент стэка - отсутсвует ИЛИ верхний элемент - закрывающая скобка*/) {
								//Кидаем ошибку
							}
							else {
								//Помещаем верхний элемент в постфикную строку
								//Удаляем элементы из стэка
							}
							//Удаляем скобку из стэка
						}
					}
					else {
						if (/*Элемент - бинарная операция*/) {
							if (/*Верхний элемент это минус*/) {
								//Смотрим элементы в стэке
								//Кароч надо обыграть этот момент
							}
							while (/*Пока верхний элемент стэка - префиксная функция ИЛИ операция на вершине стэка приоритетнее этой операции ИЛИ операция на вершине стэка с таким же приоритетом, как у этой??*/) {
								//Выталкиваем верхний элемент стэка в постфиксную строку
							}
							//Помещаем операцию в стэк
						}
					}
				}
			}
		}
	}

	//Вычисление постфискного выражения на стэке
	/*Тип возвращаемого значения*/ /*Название функции*/ (/*Входное постфиксное выражение*/) {
		for (/*Цикл по постфискному выражению*/) {
			//Обработка входного сигнала
			if (/*Операнд*/) {
				//Кидаем в вершину стэка
			}
			else {
				if (/*Операция*/) {
					//Выпаолняем операцию над соответсвующим количеством операндов
					//Унарная или бинарная
					//Не забываем операнды извлекать из стэка
					//Результат кидаем в стэк
				}
			}
		}
		return /*Вершину стэка*/;
	}

	//Вычисление одной операции
	/*Тип возвращаемого значения*/ /*Название функции*/ (/*Параметры - операнды и оператор*/) {
		switch (/*Операция*/) {
		case /*Операция 1*/:
			return /*Результат операции*/;
		case /*Операция 1*/:
			return /*Результат операции*/;
		case /*Операция 1*/:
			return /*Результат операции*/;
		case /*Операция 1*/:
			return /*Результат операции*/;
		//И так со всеми операциями
		default: //На всякий случай
			/*Ошибка*/;
		}
	}

	//Первичная обработка входного выражения
	/*Тип функции*/ /*Название*/ (/*Входное выражение*/) {
		for (/*Цикл по символам строки*/) {
			if (/*Текущий символ - цифра или точка*/) {
				if (/*Текущий элемент - первый*/) {
					//Создаем новый элемент-операнд и кидаем его туда
					//Меняем показатель - операнд или оператор
				}
				else {
					if (/*Предыдущий элемент - не цифра или точка*/) {
						//Создаем новый элемент-операнд и кидаем его туда
						//Меняем показатель - операнд или оператор
						//Прибавляем итератор элементов выражения
					}
					else {
						//Добавляем символ к текущему элементу
					}
				}
			}
			else {
				if (/*Текущий элемент - операция*/) {
					//Создаем новый элемент-оператор и кидаем его туда
					//Меняем показатель - операнд или оператор
					//Прибавляем значение итератора по элементам выражения
				}
				else {
					if (/*Текущий символ - буква*/) {
						if (/*Текущий элемент первый*/) {
							//Создаем новый элемент-оператор и кидаем его туда
							//Меняем показатель - операнд или оператор
						}
						else {
							if (/*Предыдущий элемент - операнд*/) {
								//Создаем новый элемент-оператор и кидаем его туда
								//Меняем показатель - операнд или оператор
								//Прибавляем значение итератора по элементам выражения
							}
							else {
								//Добавляем символ к текущему элементу
							}
						}
					} 
					else {
						if (/*Текущий элемент - пробел или табуляция*/) {
							//Благополучно его пропускаем
						}
						else {
							//Кидаем ошибку
						}
					}
				}
			}
		}
	}

	/*Вторичная обработка инфиксного выражения или фильтрация операторов*/
	/*Тип функции*/ /*Название функции*/ (/*Входное инфиксное выражение*/) {
		for (/*Цикл по элементам выражения*/) {
			if (/*Текущий элемент - операнд*/) {
				if (/*Текущий элемент - бинарный оператор*/) {
					//Устанавливаем в нем, что он бинарный оператор
				}
				else {
					if (/*Текущий элемент - унарный оператор*/) {
						//Устанвливаем в нем, что он унарный оператор
					}
					else {
						if (/*Текущий элемент - константа*/) {
							//Кидаем его в операнды и говорим, что он константа
						}
						else {
							//Либо кидаем ошибку
							//Либо говорим, что он переменная и кидаем в операнды
						}
					}
				}
			}
		}
	}

	//
}